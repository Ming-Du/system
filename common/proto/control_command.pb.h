// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control_command.proto

#ifndef PROTOBUF_control_5fcommand_2eproto__INCLUDED
#define PROTOBUF_control_5fcommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
#include "chassis.pb.h"
// @@protoc_insertion_point(includes)

namespace chassis {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_control_5fcommand_2eproto();
void protobuf_AssignDesc_control_5fcommand_2eproto();
void protobuf_ShutdownFile_control_5fcommand_2eproto();

class ControlCommand;

// ===================================================================

class ControlCommand : public ::google::protobuf::Message {
 public:
  ControlCommand();
  virtual ~ControlCommand();

  ControlCommand(const ControlCommand& from);

  inline ControlCommand& operator=(const ControlCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlCommand& default_instance();

  void Swap(ControlCommand* other);

  // implements Message ----------------------------------------------

  ControlCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlCommand& from);
  void MergeFrom(const ControlCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::common::Header& header() const;
  inline ::common::Header* mutable_header();
  inline ::common::Header* release_header();
  inline void set_allocated_header(::common::Header* header);

  // optional .chassis.PilotMode pilot_mode = 2 [default = MODE_MANUAL];
  inline bool has_pilot_mode() const;
  inline void clear_pilot_mode();
  static const int kPilotModeFieldNumber = 2;
  inline ::chassis::PilotMode pilot_mode() const;
  inline void set_pilot_mode(::chassis::PilotMode value);

  // optional float steering = 3 [default = 0];
  inline bool has_steering() const;
  inline void clear_steering();
  static const int kSteeringFieldNumber = 3;
  inline float steering() const;
  inline void set_steering(float value);

  // optional float speed = 4 [default = 0];
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline float speed() const;
  inline void set_speed(float value);

  // optional float accel = 5 [default = 0];
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 5;
  inline float accel() const;
  inline void set_accel(float value);

  // optional float throttle = 6 [default = 0];
  inline bool has_throttle() const;
  inline void clear_throttle();
  static const int kThrottleFieldNumber = 6;
  inline float throttle() const;
  inline void set_throttle(float value);

  // optional float brake = 7 [default = 0];
  inline bool has_brake() const;
  inline void clear_brake();
  static const int kBrakeFieldNumber = 7;
  inline float brake() const;
  inline void set_brake(float value);

  // optional .chassis.GearPosition gear = 8 [default = GEAR_NONE];
  inline bool has_gear() const;
  inline void clear_gear();
  static const int kGearFieldNumber = 8;
  inline ::chassis::GearPosition gear() const;
  inline void set_gear(::chassis::GearPosition value);

  // optional .chassis.LightSwitch light = 9 [default = LIGHT_NONE];
  inline bool has_light() const;
  inline void clear_light();
  static const int kLightFieldNumber = 9;
  inline ::chassis::LightSwitch light() const;
  inline void set_light(::chassis::LightSwitch value);

  // optional bool horn = 10 [default = false];
  inline bool has_horn() const;
  inline void clear_horn();
  static const int kHornFieldNumber = 10;
  inline bool horn() const;
  inline void set_horn(bool value);

  // optional bool highbeam = 11 [default = false];
  inline bool has_highbeam() const;
  inline void clear_highbeam();
  static const int kHighbeamFieldNumber = 11;
  inline bool highbeam() const;
  inline void set_highbeam(bool value);

  // optional bool lowbeam = 12 [default = false];
  inline bool has_lowbeam() const;
  inline void clear_lowbeam();
  static const int kLowbeamFieldNumber = 12;
  inline bool lowbeam() const;
  inline void set_lowbeam(bool value);

  // optional bool foglight = 13 [default = false];
  inline bool has_foglight() const;
  inline void clear_foglight();
  static const int kFoglightFieldNumber = 13;
  inline bool foglight() const;
  inline void set_foglight(bool value);

  // optional bool clearance_lamps = 14 [default = false];
  inline bool has_clearance_lamps() const;
  inline void clear_clearance_lamps();
  static const int kClearanceLampsFieldNumber = 14;
  inline bool clearance_lamps() const;
  inline void set_clearance_lamps(bool value);

  // optional bool warn_light = 15 [default = false];
  inline bool has_warn_light() const;
  inline void clear_warn_light();
  static const int kWarnLightFieldNumber = 15;
  inline bool warn_light() const;
  inline void set_warn_light(bool value);

  // optional bool parking_brake = 16 [default = false];
  inline bool has_parking_brake() const;
  inline void clear_parking_brake();
  static const int kParkingBrakeFieldNumber = 16;
  inline bool parking_brake() const;
  inline void set_parking_brake(bool value);

  // optional bool drive_off = 20;
  inline bool has_drive_off() const;
  inline void clear_drive_off();
  static const int kDriveOffFieldNumber = 20;
  inline bool drive_off() const;
  inline void set_drive_off(bool value);

  // optional bool dec_to_stop = 21;
  inline bool has_dec_to_stop() const;
  inline void clear_dec_to_stop();
  static const int kDecToStopFieldNumber = 21;
  inline bool dec_to_stop() const;
  inline void set_dec_to_stop(bool value);

  // @@protoc_insertion_point(class_scope:chassis.ControlCommand)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pilot_mode();
  inline void clear_has_pilot_mode();
  inline void set_has_steering();
  inline void clear_has_steering();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_throttle();
  inline void clear_has_throttle();
  inline void set_has_brake();
  inline void clear_has_brake();
  inline void set_has_gear();
  inline void clear_has_gear();
  inline void set_has_light();
  inline void clear_has_light();
  inline void set_has_horn();
  inline void clear_has_horn();
  inline void set_has_highbeam();
  inline void clear_has_highbeam();
  inline void set_has_lowbeam();
  inline void clear_has_lowbeam();
  inline void set_has_foglight();
  inline void clear_has_foglight();
  inline void set_has_clearance_lamps();
  inline void clear_has_clearance_lamps();
  inline void set_has_warn_light();
  inline void clear_has_warn_light();
  inline void set_has_parking_brake();
  inline void clear_has_parking_brake();
  inline void set_has_drive_off();
  inline void clear_has_drive_off();
  inline void set_has_dec_to_stop();
  inline void clear_has_dec_to_stop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::Header* header_;
  int pilot_mode_;
  float steering_;
  float speed_;
  float accel_;
  float throttle_;
  float brake_;
  int gear_;
  int light_;
  bool horn_;
  bool highbeam_;
  bool lowbeam_;
  bool foglight_;
  bool clearance_lamps_;
  bool warn_light_;
  bool parking_brake_;
  bool drive_off_;
  bool dec_to_stop_;
  friend void  protobuf_AddDesc_control_5fcommand_2eproto();
  friend void protobuf_AssignDesc_control_5fcommand_2eproto();
  friend void protobuf_ShutdownFile_control_5fcommand_2eproto();

  void InitAsDefaultInstance();
  static ControlCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// ControlCommand

// optional .common.Header header = 1;
inline bool ControlCommand::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlCommand::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlCommand::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlCommand::clear_header() {
  if (header_ != NULL) header_->::common::Header::Clear();
  clear_has_header();
}
inline const ::common::Header& ControlCommand::header() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::common::Header* ControlCommand::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::common::Header;
  // @@protoc_insertion_point(field_mutable:chassis.ControlCommand.header)
  return header_;
}
inline ::common::Header* ControlCommand::release_header() {
  clear_has_header();
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ControlCommand::set_allocated_header(::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:chassis.ControlCommand.header)
}

// optional .chassis.PilotMode pilot_mode = 2 [default = MODE_MANUAL];
inline bool ControlCommand::has_pilot_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlCommand::set_has_pilot_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlCommand::clear_has_pilot_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlCommand::clear_pilot_mode() {
  pilot_mode_ = 0;
  clear_has_pilot_mode();
}
inline ::chassis::PilotMode ControlCommand::pilot_mode() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.pilot_mode)
  return static_cast< ::chassis::PilotMode >(pilot_mode_);
}
inline void ControlCommand::set_pilot_mode(::chassis::PilotMode value) {
  assert(::chassis::PilotMode_IsValid(value));
  set_has_pilot_mode();
  pilot_mode_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.pilot_mode)
}

// optional float steering = 3 [default = 0];
inline bool ControlCommand::has_steering() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlCommand::set_has_steering() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlCommand::clear_has_steering() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlCommand::clear_steering() {
  steering_ = 0;
  clear_has_steering();
}
inline float ControlCommand::steering() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.steering)
  return steering_;
}
inline void ControlCommand::set_steering(float value) {
  set_has_steering();
  steering_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.steering)
}

// optional float speed = 4 [default = 0];
inline bool ControlCommand::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControlCommand::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControlCommand::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControlCommand::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float ControlCommand::speed() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.speed)
  return speed_;
}
inline void ControlCommand::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.speed)
}

// optional float accel = 5 [default = 0];
inline bool ControlCommand::has_accel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControlCommand::set_has_accel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControlCommand::clear_has_accel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControlCommand::clear_accel() {
  accel_ = 0;
  clear_has_accel();
}
inline float ControlCommand::accel() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.accel)
  return accel_;
}
inline void ControlCommand::set_accel(float value) {
  set_has_accel();
  accel_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.accel)
}

// optional float throttle = 6 [default = 0];
inline bool ControlCommand::has_throttle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ControlCommand::set_has_throttle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ControlCommand::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ControlCommand::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
inline float ControlCommand::throttle() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.throttle)
  return throttle_;
}
inline void ControlCommand::set_throttle(float value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.throttle)
}

// optional float brake = 7 [default = 0];
inline bool ControlCommand::has_brake() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ControlCommand::set_has_brake() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ControlCommand::clear_has_brake() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ControlCommand::clear_brake() {
  brake_ = 0;
  clear_has_brake();
}
inline float ControlCommand::brake() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.brake)
  return brake_;
}
inline void ControlCommand::set_brake(float value) {
  set_has_brake();
  brake_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.brake)
}

// optional .chassis.GearPosition gear = 8 [default = GEAR_NONE];
inline bool ControlCommand::has_gear() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ControlCommand::set_has_gear() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ControlCommand::clear_has_gear() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ControlCommand::clear_gear() {
  gear_ = 0;
  clear_has_gear();
}
inline ::chassis::GearPosition ControlCommand::gear() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.gear)
  return static_cast< ::chassis::GearPosition >(gear_);
}
inline void ControlCommand::set_gear(::chassis::GearPosition value) {
  assert(::chassis::GearPosition_IsValid(value));
  set_has_gear();
  gear_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.gear)
}

// optional .chassis.LightSwitch light = 9 [default = LIGHT_NONE];
inline bool ControlCommand::has_light() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ControlCommand::set_has_light() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ControlCommand::clear_has_light() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ControlCommand::clear_light() {
  light_ = 0;
  clear_has_light();
}
inline ::chassis::LightSwitch ControlCommand::light() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.light)
  return static_cast< ::chassis::LightSwitch >(light_);
}
inline void ControlCommand::set_light(::chassis::LightSwitch value) {
  assert(::chassis::LightSwitch_IsValid(value));
  set_has_light();
  light_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.light)
}

// optional bool horn = 10 [default = false];
inline bool ControlCommand::has_horn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ControlCommand::set_has_horn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ControlCommand::clear_has_horn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ControlCommand::clear_horn() {
  horn_ = false;
  clear_has_horn();
}
inline bool ControlCommand::horn() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.horn)
  return horn_;
}
inline void ControlCommand::set_horn(bool value) {
  set_has_horn();
  horn_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.horn)
}

// optional bool highbeam = 11 [default = false];
inline bool ControlCommand::has_highbeam() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ControlCommand::set_has_highbeam() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ControlCommand::clear_has_highbeam() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ControlCommand::clear_highbeam() {
  highbeam_ = false;
  clear_has_highbeam();
}
inline bool ControlCommand::highbeam() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.highbeam)
  return highbeam_;
}
inline void ControlCommand::set_highbeam(bool value) {
  set_has_highbeam();
  highbeam_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.highbeam)
}

// optional bool lowbeam = 12 [default = false];
inline bool ControlCommand::has_lowbeam() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ControlCommand::set_has_lowbeam() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ControlCommand::clear_has_lowbeam() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ControlCommand::clear_lowbeam() {
  lowbeam_ = false;
  clear_has_lowbeam();
}
inline bool ControlCommand::lowbeam() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.lowbeam)
  return lowbeam_;
}
inline void ControlCommand::set_lowbeam(bool value) {
  set_has_lowbeam();
  lowbeam_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.lowbeam)
}

// optional bool foglight = 13 [default = false];
inline bool ControlCommand::has_foglight() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ControlCommand::set_has_foglight() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ControlCommand::clear_has_foglight() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ControlCommand::clear_foglight() {
  foglight_ = false;
  clear_has_foglight();
}
inline bool ControlCommand::foglight() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.foglight)
  return foglight_;
}
inline void ControlCommand::set_foglight(bool value) {
  set_has_foglight();
  foglight_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.foglight)
}

// optional bool clearance_lamps = 14 [default = false];
inline bool ControlCommand::has_clearance_lamps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ControlCommand::set_has_clearance_lamps() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ControlCommand::clear_has_clearance_lamps() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ControlCommand::clear_clearance_lamps() {
  clearance_lamps_ = false;
  clear_has_clearance_lamps();
}
inline bool ControlCommand::clearance_lamps() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.clearance_lamps)
  return clearance_lamps_;
}
inline void ControlCommand::set_clearance_lamps(bool value) {
  set_has_clearance_lamps();
  clearance_lamps_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.clearance_lamps)
}

// optional bool warn_light = 15 [default = false];
inline bool ControlCommand::has_warn_light() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ControlCommand::set_has_warn_light() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ControlCommand::clear_has_warn_light() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ControlCommand::clear_warn_light() {
  warn_light_ = false;
  clear_has_warn_light();
}
inline bool ControlCommand::warn_light() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.warn_light)
  return warn_light_;
}
inline void ControlCommand::set_warn_light(bool value) {
  set_has_warn_light();
  warn_light_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.warn_light)
}

// optional bool parking_brake = 16 [default = false];
inline bool ControlCommand::has_parking_brake() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ControlCommand::set_has_parking_brake() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ControlCommand::clear_has_parking_brake() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ControlCommand::clear_parking_brake() {
  parking_brake_ = false;
  clear_has_parking_brake();
}
inline bool ControlCommand::parking_brake() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.parking_brake)
  return parking_brake_;
}
inline void ControlCommand::set_parking_brake(bool value) {
  set_has_parking_brake();
  parking_brake_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.parking_brake)
}

// optional bool drive_off = 20;
inline bool ControlCommand::has_drive_off() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ControlCommand::set_has_drive_off() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ControlCommand::clear_has_drive_off() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ControlCommand::clear_drive_off() {
  drive_off_ = false;
  clear_has_drive_off();
}
inline bool ControlCommand::drive_off() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.drive_off)
  return drive_off_;
}
inline void ControlCommand::set_drive_off(bool value) {
  set_has_drive_off();
  drive_off_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.drive_off)
}

// optional bool dec_to_stop = 21;
inline bool ControlCommand::has_dec_to_stop() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ControlCommand::set_has_dec_to_stop() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ControlCommand::clear_has_dec_to_stop() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ControlCommand::clear_dec_to_stop() {
  dec_to_stop_ = false;
  clear_has_dec_to_stop();
}
inline bool ControlCommand::dec_to_stop() const {
  // @@protoc_insertion_point(field_get:chassis.ControlCommand.dec_to_stop)
  return dec_to_stop_;
}
inline void ControlCommand::set_dec_to_stop(bool value) {
  set_has_dec_to_stop();
  dec_to_stop_ = value;
  // @@protoc_insertion_point(field_set:chassis.ControlCommand.dec_to_stop)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace chassis

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_control_5fcommand_2eproto__INCLUDED
