// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object.proto

#ifndef PROTOBUF_object_2eproto__INCLUDED
#define PROTOBUF_object_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
#include "geometry.pb.h"
// @@protoc_insertion_point(includes)

namespace perception {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_object_2eproto();
void protobuf_AssignDesc_object_2eproto();
void protobuf_ShutdownFile_object_2eproto();

class Object;
class VisualObject;
class VisualObjects;
class TrackedObject;
class TrackedObjects;

enum ObjectType {
  TYPE_UNKNOWN = 0,
  TYPE_PEDESTRIAN = 3,
  TYPE_BICYCLE = 4,
  TYPE_MOTOR = 5,
  TYPE_RIDER = 6,
  TYPE_CAR = 7,
  TYPE_TRUCK = 8,
  TYPE_BUS = 9,
  TYPE_TRAIN = 10,
  TYPE_SIGN = 20,
  TYPE_LIGHT = 30,
  TYPE_UNKNOWN_SMALL = 91,
  TYPE_UNKNOWN_BIG = 92,
  TYPE_UNKNOWN_STATIC = 93,
  TYPE_UNKNOWN_DYNAMIC = 94
};
bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = TYPE_UNKNOWN;
const ObjectType ObjectType_MAX = TYPE_UNKNOWN_DYNAMIC;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectType_descriptor();
inline const ::std::string& ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectType_descriptor(), value);
}
inline bool ObjectType_Parse(
    const ::std::string& name, ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
// ===================================================================

class Object : public ::google::protobuf::Message {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  Object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .perception.ObjectType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::perception::ObjectType type() const;
  inline void set_type(::perception::ObjectType value);

  // optional double timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional float confidence = 4;
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  inline float confidence() const;
  inline void set_confidence(float value);

  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional float x_distance = 6;
  inline bool has_x_distance() const;
  inline void clear_x_distance();
  static const int kXDistanceFieldNumber = 6;
  inline float x_distance() const;
  inline void set_x_distance(float value);

  // optional float y_distance = 7;
  inline bool has_y_distance() const;
  inline void clear_y_distance();
  static const int kYDistanceFieldNumber = 7;
  inline float y_distance() const;
  inline void set_y_distance(float value);

  // optional float angle = 8;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 8;
  inline float angle() const;
  inline void set_angle(float value);

  // optional .geometry.Point center = 9;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 9;
  inline const ::geometry::Point& center() const;
  inline ::geometry::Point* mutable_center();
  inline ::geometry::Point* release_center();
  inline void set_allocated_center(::geometry::Point* center);

  // optional .geometry.Vector3 size = 10;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 10;
  inline const ::geometry::Vector3& size() const;
  inline ::geometry::Vector3* mutable_size();
  inline ::geometry::Vector3* release_size();
  inline void set_allocated_size(::geometry::Vector3* size);

  // repeated .geometry.Point contour = 11;
  inline int contour_size() const;
  inline void clear_contour();
  static const int kContourFieldNumber = 11;
  inline const ::geometry::Point& contour(int index) const;
  inline ::geometry::Point* mutable_contour(int index);
  inline ::geometry::Point* add_contour();
  inline const ::google::protobuf::RepeatedPtrField< ::geometry::Point >&
      contour() const;
  inline ::google::protobuf::RepeatedPtrField< ::geometry::Point >*
      mutable_contour();

  // @@protoc_insertion_point(class_scope:perception.Object)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_x_distance();
  inline void clear_has_x_distance();
  inline void set_has_y_distance();
  inline void clear_has_y_distance();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  int type_;
  double timestamp_;
  float confidence_;
  ::google::protobuf::int32 status_;
  float x_distance_;
  float y_distance_;
  ::geometry::Point* center_;
  ::geometry::Vector3* size_;
  ::google::protobuf::RepeatedPtrField< ::geometry::Point > contour_;
  float angle_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Object* default_instance_;
};
// -------------------------------------------------------------------

class VisualObject : public ::google::protobuf::Message {
 public:
  VisualObject();
  virtual ~VisualObject();

  VisualObject(const VisualObject& from);

  inline VisualObject& operator=(const VisualObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisualObject& default_instance();

  void Swap(VisualObject* other);

  // implements Message ----------------------------------------------

  VisualObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisualObject& from);
  void MergeFrom(const VisualObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perception.Object obj = 1;
  inline bool has_obj() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 1;
  inline const ::perception::Object& obj() const;
  inline ::perception::Object* mutable_obj();
  inline ::perception::Object* release_obj();
  inline void set_allocated_obj(::perception::Object* obj);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perception.VisualObject)
 private:
  inline void set_has_obj();
  inline void clear_has_obj();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perception::Object* obj_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static VisualObject* default_instance_;
};
// -------------------------------------------------------------------

class VisualObjects : public ::google::protobuf::Message {
 public:
  VisualObjects();
  virtual ~VisualObjects();

  VisualObjects(const VisualObjects& from);

  inline VisualObjects& operator=(const VisualObjects& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisualObjects& default_instance();

  void Swap(VisualObjects* other);

  // implements Message ----------------------------------------------

  VisualObjects* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisualObjects& from);
  void MergeFrom(const VisualObjects& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::common::Header& header() const;
  inline ::common::Header* mutable_header();
  inline ::common::Header* release_header();
  inline void set_allocated_header(::common::Header* header);

  // repeated .perception.VisualObject objs = 2;
  inline int objs_size() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 2;
  inline const ::perception::VisualObject& objs(int index) const;
  inline ::perception::VisualObject* mutable_objs(int index);
  inline ::perception::VisualObject* add_objs();
  inline const ::google::protobuf::RepeatedPtrField< ::perception::VisualObject >&
      objs() const;
  inline ::google::protobuf::RepeatedPtrField< ::perception::VisualObject >*
      mutable_objs();

  // @@protoc_insertion_point(class_scope:perception.VisualObjects)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::Header* header_;
  ::google::protobuf::RepeatedPtrField< ::perception::VisualObject > objs_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static VisualObjects* default_instance_;
};
// -------------------------------------------------------------------

class TrackedObject : public ::google::protobuf::Message {
 public:
  TrackedObject();
  virtual ~TrackedObject();

  TrackedObject(const TrackedObject& from);

  inline TrackedObject& operator=(const TrackedObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackedObject& default_instance();

  void Swap(TrackedObject* other);

  // implements Message ----------------------------------------------

  TrackedObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackedObject& from);
  void MergeFrom(const TrackedObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perception.Object obj = 1;
  inline bool has_obj() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 1;
  inline const ::perception::Object& obj() const;
  inline ::perception::Object* mutable_obj();
  inline ::perception::Object* release_obj();
  inline void set_allocated_obj(::perception::Object* obj);

  // optional float yaw = 2;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 2;
  inline float yaw() const;
  inline void set_yaw(float value);

  // optional float yaw_rate = 3;
  inline bool has_yaw_rate() const;
  inline void clear_yaw_rate();
  static const int kYawRateFieldNumber = 3;
  inline float yaw_rate() const;
  inline void set_yaw_rate(float value);

  // optional .geometry.Vector3 velocity = 4;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  inline const ::geometry::Vector3& velocity() const;
  inline ::geometry::Vector3* mutable_velocity();
  inline ::geometry::Vector3* release_velocity();
  inline void set_allocated_velocity(::geometry::Vector3* velocity);

  // repeated .geometry.Point trace = 5;
  inline int trace_size() const;
  inline void clear_trace();
  static const int kTraceFieldNumber = 5;
  inline const ::geometry::Point& trace(int index) const;
  inline ::geometry::Point* mutable_trace(int index);
  inline ::geometry::Point* add_trace();
  inline const ::google::protobuf::RepeatedPtrField< ::geometry::Point >&
      trace() const;
  inline ::google::protobuf::RepeatedPtrField< ::geometry::Point >*
      mutable_trace();

  // optional float absolute_longitude_v = 6;
  inline bool has_absolute_longitude_v() const;
  inline void clear_absolute_longitude_v();
  static const int kAbsoluteLongitudeVFieldNumber = 6;
  inline float absolute_longitude_v() const;
  inline void set_absolute_longitude_v(float value);

  // optional float absolute_longitude_a = 7;
  inline bool has_absolute_longitude_a() const;
  inline void clear_absolute_longitude_a();
  static const int kAbsoluteLongitudeAFieldNumber = 7;
  inline float absolute_longitude_a() const;
  inline void set_absolute_longitude_a(float value);

  // optional float absolute_lateral_v = 8;
  inline bool has_absolute_lateral_v() const;
  inline void clear_absolute_lateral_v();
  static const int kAbsoluteLateralVFieldNumber = 8;
  inline float absolute_lateral_v() const;
  inline void set_absolute_lateral_v(float value);

  // @@protoc_insertion_point(class_scope:perception.TrackedObject)
 private:
  inline void set_has_obj();
  inline void clear_has_obj();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_yaw_rate();
  inline void clear_has_yaw_rate();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_absolute_longitude_v();
  inline void clear_has_absolute_longitude_v();
  inline void set_has_absolute_longitude_a();
  inline void clear_has_absolute_longitude_a();
  inline void set_has_absolute_lateral_v();
  inline void clear_has_absolute_lateral_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perception::Object* obj_;
  float yaw_;
  float yaw_rate_;
  ::geometry::Vector3* velocity_;
  ::google::protobuf::RepeatedPtrField< ::geometry::Point > trace_;
  float absolute_longitude_v_;
  float absolute_longitude_a_;
  float absolute_lateral_v_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static TrackedObject* default_instance_;
};
// -------------------------------------------------------------------

class TrackedObjects : public ::google::protobuf::Message {
 public:
  TrackedObjects();
  virtual ~TrackedObjects();

  TrackedObjects(const TrackedObjects& from);

  inline TrackedObjects& operator=(const TrackedObjects& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackedObjects& default_instance();

  void Swap(TrackedObjects* other);

  // implements Message ----------------------------------------------

  TrackedObjects* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackedObjects& from);
  void MergeFrom(const TrackedObjects& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::common::Header& header() const;
  inline ::common::Header* mutable_header();
  inline ::common::Header* release_header();
  inline void set_allocated_header(::common::Header* header);

  // repeated .perception.TrackedObject objs = 2;
  inline int objs_size() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 2;
  inline const ::perception::TrackedObject& objs(int index) const;
  inline ::perception::TrackedObject* mutable_objs(int index);
  inline ::perception::TrackedObject* add_objs();
  inline const ::google::protobuf::RepeatedPtrField< ::perception::TrackedObject >&
      objs() const;
  inline ::google::protobuf::RepeatedPtrField< ::perception::TrackedObject >*
      mutable_objs();

  // @@protoc_insertion_point(class_scope:perception.TrackedObjects)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::Header* header_;
  ::google::protobuf::RepeatedPtrField< ::perception::TrackedObject > objs_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static TrackedObjects* default_instance_;
};
// ===================================================================


// ===================================================================

// Object

// optional uint32 id = 1;
inline bool Object::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Object::id() const {
  // @@protoc_insertion_point(field_get:perception.Object.id)
  return id_;
}
inline void Object::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.id)
}

// optional .perception.ObjectType type = 2;
inline bool Object::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::perception::ObjectType Object::type() const {
  // @@protoc_insertion_point(field_get:perception.Object.type)
  return static_cast< ::perception::ObjectType >(type_);
}
inline void Object::set_type(::perception::ObjectType value) {
  assert(::perception::ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.type)
}

// optional double timestamp = 3;
inline bool Object::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Object::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Object::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Object::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Object::timestamp() const {
  // @@protoc_insertion_point(field_get:perception.Object.timestamp)
  return timestamp_;
}
inline void Object::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.timestamp)
}

// optional float confidence = 4;
inline bool Object::has_confidence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Object::set_has_confidence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Object::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Object::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float Object::confidence() const {
  // @@protoc_insertion_point(field_get:perception.Object.confidence)
  return confidence_;
}
inline void Object::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.confidence)
}

// optional int32 status = 5;
inline bool Object::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Object::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Object::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Object::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Object::status() const {
  // @@protoc_insertion_point(field_get:perception.Object.status)
  return status_;
}
inline void Object::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.status)
}

// optional float x_distance = 6;
inline bool Object::has_x_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Object::set_has_x_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Object::clear_has_x_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Object::clear_x_distance() {
  x_distance_ = 0;
  clear_has_x_distance();
}
inline float Object::x_distance() const {
  // @@protoc_insertion_point(field_get:perception.Object.x_distance)
  return x_distance_;
}
inline void Object::set_x_distance(float value) {
  set_has_x_distance();
  x_distance_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.x_distance)
}

// optional float y_distance = 7;
inline bool Object::has_y_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Object::set_has_y_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Object::clear_has_y_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Object::clear_y_distance() {
  y_distance_ = 0;
  clear_has_y_distance();
}
inline float Object::y_distance() const {
  // @@protoc_insertion_point(field_get:perception.Object.y_distance)
  return y_distance_;
}
inline void Object::set_y_distance(float value) {
  set_has_y_distance();
  y_distance_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.y_distance)
}

// optional float angle = 8;
inline bool Object::has_angle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Object::set_has_angle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Object::clear_has_angle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Object::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Object::angle() const {
  // @@protoc_insertion_point(field_get:perception.Object.angle)
  return angle_;
}
inline void Object::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:perception.Object.angle)
}

// optional .geometry.Point center = 9;
inline bool Object::has_center() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Object::set_has_center() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Object::clear_has_center() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Object::clear_center() {
  if (center_ != NULL) center_->::geometry::Point::Clear();
  clear_has_center();
}
inline const ::geometry::Point& Object::center() const {
  // @@protoc_insertion_point(field_get:perception.Object.center)
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::geometry::Point* Object::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::geometry::Point;
  // @@protoc_insertion_point(field_mutable:perception.Object.center)
  return center_;
}
inline ::geometry::Point* Object::release_center() {
  clear_has_center();
  ::geometry::Point* temp = center_;
  center_ = NULL;
  return temp;
}
inline void Object::set_allocated_center(::geometry::Point* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.Object.center)
}

// optional .geometry.Vector3 size = 10;
inline bool Object::has_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Object::set_has_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Object::clear_has_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Object::clear_size() {
  if (size_ != NULL) size_->::geometry::Vector3::Clear();
  clear_has_size();
}
inline const ::geometry::Vector3& Object::size() const {
  // @@protoc_insertion_point(field_get:perception.Object.size)
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::geometry::Vector3* Object::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:perception.Object.size)
  return size_;
}
inline ::geometry::Vector3* Object::release_size() {
  clear_has_size();
  ::geometry::Vector3* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Object::set_allocated_size(::geometry::Vector3* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.Object.size)
}

// repeated .geometry.Point contour = 11;
inline int Object::contour_size() const {
  return contour_.size();
}
inline void Object::clear_contour() {
  contour_.Clear();
}
inline const ::geometry::Point& Object::contour(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.contour)
  return contour_.Get(index);
}
inline ::geometry::Point* Object::mutable_contour(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.contour)
  return contour_.Mutable(index);
}
inline ::geometry::Point* Object::add_contour() {
  // @@protoc_insertion_point(field_add:perception.Object.contour)
  return contour_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geometry::Point >&
Object::contour() const {
  // @@protoc_insertion_point(field_list:perception.Object.contour)
  return contour_;
}
inline ::google::protobuf::RepeatedPtrField< ::geometry::Point >*
Object::mutable_contour() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.contour)
  return &contour_;
}

// -------------------------------------------------------------------

// VisualObject

// optional .perception.Object obj = 1;
inline bool VisualObject::has_obj() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisualObject::set_has_obj() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisualObject::clear_has_obj() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisualObject::clear_obj() {
  if (obj_ != NULL) obj_->::perception::Object::Clear();
  clear_has_obj();
}
inline const ::perception::Object& VisualObject::obj() const {
  // @@protoc_insertion_point(field_get:perception.VisualObject.obj)
  return obj_ != NULL ? *obj_ : *default_instance_->obj_;
}
inline ::perception::Object* VisualObject::mutable_obj() {
  set_has_obj();
  if (obj_ == NULL) obj_ = new ::perception::Object;
  // @@protoc_insertion_point(field_mutable:perception.VisualObject.obj)
  return obj_;
}
inline ::perception::Object* VisualObject::release_obj() {
  clear_has_obj();
  ::perception::Object* temp = obj_;
  obj_ = NULL;
  return temp;
}
inline void VisualObject::set_allocated_obj(::perception::Object* obj) {
  delete obj_;
  obj_ = obj;
  if (obj) {
    set_has_obj();
  } else {
    clear_has_obj();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.VisualObject.obj)
}

// optional int32 x = 2;
inline bool VisualObject::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisualObject::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisualObject::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisualObject::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 VisualObject::x() const {
  // @@protoc_insertion_point(field_get:perception.VisualObject.x)
  return x_;
}
inline void VisualObject::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:perception.VisualObject.x)
}

// optional int32 y = 3;
inline bool VisualObject::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VisualObject::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VisualObject::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VisualObject::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 VisualObject::y() const {
  // @@protoc_insertion_point(field_get:perception.VisualObject.y)
  return y_;
}
inline void VisualObject::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:perception.VisualObject.y)
}

// optional int32 width = 4;
inline bool VisualObject::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VisualObject::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VisualObject::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VisualObject::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 VisualObject::width() const {
  // @@protoc_insertion_point(field_get:perception.VisualObject.width)
  return width_;
}
inline void VisualObject::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:perception.VisualObject.width)
}

// optional int32 height = 5;
inline bool VisualObject::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VisualObject::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VisualObject::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VisualObject::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 VisualObject::height() const {
  // @@protoc_insertion_point(field_get:perception.VisualObject.height)
  return height_;
}
inline void VisualObject::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:perception.VisualObject.height)
}

// -------------------------------------------------------------------

// VisualObjects

// optional .common.Header header = 1;
inline bool VisualObjects::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisualObjects::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisualObjects::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisualObjects::clear_header() {
  if (header_ != NULL) header_->::common::Header::Clear();
  clear_has_header();
}
inline const ::common::Header& VisualObjects::header() const {
  // @@protoc_insertion_point(field_get:perception.VisualObjects.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::common::Header* VisualObjects::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::common::Header;
  // @@protoc_insertion_point(field_mutable:perception.VisualObjects.header)
  return header_;
}
inline ::common::Header* VisualObjects::release_header() {
  clear_has_header();
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void VisualObjects::set_allocated_header(::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.VisualObjects.header)
}

// repeated .perception.VisualObject objs = 2;
inline int VisualObjects::objs_size() const {
  return objs_.size();
}
inline void VisualObjects::clear_objs() {
  objs_.Clear();
}
inline const ::perception::VisualObject& VisualObjects::objs(int index) const {
  // @@protoc_insertion_point(field_get:perception.VisualObjects.objs)
  return objs_.Get(index);
}
inline ::perception::VisualObject* VisualObjects::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:perception.VisualObjects.objs)
  return objs_.Mutable(index);
}
inline ::perception::VisualObject* VisualObjects::add_objs() {
  // @@protoc_insertion_point(field_add:perception.VisualObjects.objs)
  return objs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::VisualObject >&
VisualObjects::objs() const {
  // @@protoc_insertion_point(field_list:perception.VisualObjects.objs)
  return objs_;
}
inline ::google::protobuf::RepeatedPtrField< ::perception::VisualObject >*
VisualObjects::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:perception.VisualObjects.objs)
  return &objs_;
}

// -------------------------------------------------------------------

// TrackedObject

// optional .perception.Object obj = 1;
inline bool TrackedObject::has_obj() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackedObject::set_has_obj() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackedObject::clear_has_obj() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackedObject::clear_obj() {
  if (obj_ != NULL) obj_->::perception::Object::Clear();
  clear_has_obj();
}
inline const ::perception::Object& TrackedObject::obj() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.obj)
  return obj_ != NULL ? *obj_ : *default_instance_->obj_;
}
inline ::perception::Object* TrackedObject::mutable_obj() {
  set_has_obj();
  if (obj_ == NULL) obj_ = new ::perception::Object;
  // @@protoc_insertion_point(field_mutable:perception.TrackedObject.obj)
  return obj_;
}
inline ::perception::Object* TrackedObject::release_obj() {
  clear_has_obj();
  ::perception::Object* temp = obj_;
  obj_ = NULL;
  return temp;
}
inline void TrackedObject::set_allocated_obj(::perception::Object* obj) {
  delete obj_;
  obj_ = obj;
  if (obj) {
    set_has_obj();
  } else {
    clear_has_obj();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.TrackedObject.obj)
}

// optional float yaw = 2;
inline bool TrackedObject::has_yaw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackedObject::set_has_yaw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackedObject::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackedObject::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float TrackedObject::yaw() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.yaw)
  return yaw_;
}
inline void TrackedObject::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:perception.TrackedObject.yaw)
}

// optional float yaw_rate = 3;
inline bool TrackedObject::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackedObject::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackedObject::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackedObject::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline float TrackedObject::yaw_rate() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.yaw_rate)
  return yaw_rate_;
}
inline void TrackedObject::set_yaw_rate(float value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:perception.TrackedObject.yaw_rate)
}

// optional .geometry.Vector3 velocity = 4;
inline bool TrackedObject::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackedObject::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackedObject::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackedObject::clear_velocity() {
  if (velocity_ != NULL) velocity_->::geometry::Vector3::Clear();
  clear_has_velocity();
}
inline const ::geometry::Vector3& TrackedObject::velocity() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::geometry::Vector3* TrackedObject::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:perception.TrackedObject.velocity)
  return velocity_;
}
inline ::geometry::Vector3* TrackedObject::release_velocity() {
  clear_has_velocity();
  ::geometry::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void TrackedObject::set_allocated_velocity(::geometry::Vector3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.TrackedObject.velocity)
}

// repeated .geometry.Point trace = 5;
inline int TrackedObject::trace_size() const {
  return trace_.size();
}
inline void TrackedObject::clear_trace() {
  trace_.Clear();
}
inline const ::geometry::Point& TrackedObject::trace(int index) const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.trace)
  return trace_.Get(index);
}
inline ::geometry::Point* TrackedObject::mutable_trace(int index) {
  // @@protoc_insertion_point(field_mutable:perception.TrackedObject.trace)
  return trace_.Mutable(index);
}
inline ::geometry::Point* TrackedObject::add_trace() {
  // @@protoc_insertion_point(field_add:perception.TrackedObject.trace)
  return trace_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geometry::Point >&
TrackedObject::trace() const {
  // @@protoc_insertion_point(field_list:perception.TrackedObject.trace)
  return trace_;
}
inline ::google::protobuf::RepeatedPtrField< ::geometry::Point >*
TrackedObject::mutable_trace() {
  // @@protoc_insertion_point(field_mutable_list:perception.TrackedObject.trace)
  return &trace_;
}

// optional float absolute_longitude_v = 6;
inline bool TrackedObject::has_absolute_longitude_v() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackedObject::set_has_absolute_longitude_v() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackedObject::clear_has_absolute_longitude_v() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackedObject::clear_absolute_longitude_v() {
  absolute_longitude_v_ = 0;
  clear_has_absolute_longitude_v();
}
inline float TrackedObject::absolute_longitude_v() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.absolute_longitude_v)
  return absolute_longitude_v_;
}
inline void TrackedObject::set_absolute_longitude_v(float value) {
  set_has_absolute_longitude_v();
  absolute_longitude_v_ = value;
  // @@protoc_insertion_point(field_set:perception.TrackedObject.absolute_longitude_v)
}

// optional float absolute_longitude_a = 7;
inline bool TrackedObject::has_absolute_longitude_a() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackedObject::set_has_absolute_longitude_a() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackedObject::clear_has_absolute_longitude_a() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackedObject::clear_absolute_longitude_a() {
  absolute_longitude_a_ = 0;
  clear_has_absolute_longitude_a();
}
inline float TrackedObject::absolute_longitude_a() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.absolute_longitude_a)
  return absolute_longitude_a_;
}
inline void TrackedObject::set_absolute_longitude_a(float value) {
  set_has_absolute_longitude_a();
  absolute_longitude_a_ = value;
  // @@protoc_insertion_point(field_set:perception.TrackedObject.absolute_longitude_a)
}

// optional float absolute_lateral_v = 8;
inline bool TrackedObject::has_absolute_lateral_v() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrackedObject::set_has_absolute_lateral_v() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrackedObject::clear_has_absolute_lateral_v() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrackedObject::clear_absolute_lateral_v() {
  absolute_lateral_v_ = 0;
  clear_has_absolute_lateral_v();
}
inline float TrackedObject::absolute_lateral_v() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObject.absolute_lateral_v)
  return absolute_lateral_v_;
}
inline void TrackedObject::set_absolute_lateral_v(float value) {
  set_has_absolute_lateral_v();
  absolute_lateral_v_ = value;
  // @@protoc_insertion_point(field_set:perception.TrackedObject.absolute_lateral_v)
}

// -------------------------------------------------------------------

// TrackedObjects

// optional .common.Header header = 1;
inline bool TrackedObjects::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackedObjects::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackedObjects::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackedObjects::clear_header() {
  if (header_ != NULL) header_->::common::Header::Clear();
  clear_has_header();
}
inline const ::common::Header& TrackedObjects::header() const {
  // @@protoc_insertion_point(field_get:perception.TrackedObjects.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::common::Header* TrackedObjects::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::common::Header;
  // @@protoc_insertion_point(field_mutable:perception.TrackedObjects.header)
  return header_;
}
inline ::common::Header* TrackedObjects::release_header() {
  clear_has_header();
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TrackedObjects::set_allocated_header(::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.TrackedObjects.header)
}

// repeated .perception.TrackedObject objs = 2;
inline int TrackedObjects::objs_size() const {
  return objs_.size();
}
inline void TrackedObjects::clear_objs() {
  objs_.Clear();
}
inline const ::perception::TrackedObject& TrackedObjects::objs(int index) const {
  // @@protoc_insertion_point(field_get:perception.TrackedObjects.objs)
  return objs_.Get(index);
}
inline ::perception::TrackedObject* TrackedObjects::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:perception.TrackedObjects.objs)
  return objs_.Mutable(index);
}
inline ::perception::TrackedObject* TrackedObjects::add_objs() {
  // @@protoc_insertion_point(field_add:perception.TrackedObjects.objs)
  return objs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::TrackedObject >&
TrackedObjects::objs() const {
  // @@protoc_insertion_point(field_list:perception.TrackedObjects.objs)
  return objs_;
}
inline ::google::protobuf::RepeatedPtrField< ::perception::TrackedObject >*
TrackedObjects::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:perception.TrackedObjects.objs)
  return &objs_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perception::ObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::ObjectType>() {
  return ::perception::ObjectType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_object_2eproto__INCLUDED
