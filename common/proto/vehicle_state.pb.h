// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vehicle_state.proto

#ifndef PROTOBUF_vehicle_5fstate_2eproto__INCLUDED
#define PROTOBUF_vehicle_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
#include "chassis.pb.h"
// @@protoc_insertion_point(includes)

namespace chassis {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vehicle_5fstate_2eproto();
void protobuf_AssignDesc_vehicle_5fstate_2eproto();
void protobuf_ShutdownFile_vehicle_5fstate_2eproto();

class VehicleState;

// ===================================================================

class VehicleState : public ::google::protobuf::Message {
 public:
  VehicleState();
  virtual ~VehicleState();

  VehicleState(const VehicleState& from);

  inline VehicleState& operator=(const VehicleState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleState& default_instance();

  void Swap(VehicleState* other);

  // implements Message ----------------------------------------------

  VehicleState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleState& from);
  void MergeFrom(const VehicleState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::common::Header& header() const;
  inline ::common::Header* mutable_header();
  inline ::common::Header* release_header();
  inline void set_allocated_header(::common::Header* header);

  // optional .chassis.PilotMode pilot_mode = 2 [default = MODE_MANUAL];
  inline bool has_pilot_mode() const;
  inline void clear_pilot_mode();
  static const int kPilotModeFieldNumber = 2;
  inline ::chassis::PilotMode pilot_mode() const;
  inline void set_pilot_mode(::chassis::PilotMode value);

  // optional float steering = 3 [default = 0];
  inline bool has_steering() const;
  inline void clear_steering();
  static const int kSteeringFieldNumber = 3;
  inline float steering() const;
  inline void set_steering(float value);

  // optional float speed = 4 [default = 0];
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline float speed() const;
  inline void set_speed(float value);

  // optional float accel = 5 [default = 0];
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 5;
  inline float accel() const;
  inline void set_accel(float value);

  // optional float throttle = 6 [default = 0];
  inline bool has_throttle() const;
  inline void clear_throttle();
  static const int kThrottleFieldNumber = 6;
  inline float throttle() const;
  inline void set_throttle(float value);

  // optional float brake = 7 [default = 0];
  inline bool has_brake() const;
  inline void clear_brake();
  static const int kBrakeFieldNumber = 7;
  inline float brake() const;
  inline void set_brake(float value);

  // optional .chassis.GearPosition gear = 8 [default = GEAR_NONE];
  inline bool has_gear() const;
  inline void clear_gear();
  static const int kGearFieldNumber = 8;
  inline ::chassis::GearPosition gear() const;
  inline void set_gear(::chassis::GearPosition value);

  // optional .chassis.LightSwitch light = 9 [default = LIGHT_NONE];
  inline bool has_light() const;
  inline void clear_light();
  static const int kLightFieldNumber = 9;
  inline ::chassis::LightSwitch light() const;
  inline void set_light(::chassis::LightSwitch value);

  // optional bool horn = 10 [default = false];
  inline bool has_horn() const;
  inline void clear_horn();
  static const int kHornFieldNumber = 10;
  inline bool horn() const;
  inline void set_horn(bool value);

  // optional bool highbeam = 11 [default = false];
  inline bool has_highbeam() const;
  inline void clear_highbeam();
  static const int kHighbeamFieldNumber = 11;
  inline bool highbeam() const;
  inline void set_highbeam(bool value);

  // optional bool lowbeam = 12 [default = false];
  inline bool has_lowbeam() const;
  inline void clear_lowbeam();
  static const int kLowbeamFieldNumber = 12;
  inline bool lowbeam() const;
  inline void set_lowbeam(bool value);

  // optional bool foglight = 13 [default = false];
  inline bool has_foglight() const;
  inline void clear_foglight();
  static const int kFoglightFieldNumber = 13;
  inline bool foglight() const;
  inline void set_foglight(bool value);

  // optional bool clearance_lamps = 14 [default = false];
  inline bool has_clearance_lamps() const;
  inline void clear_clearance_lamps();
  static const int kClearanceLampsFieldNumber = 14;
  inline bool clearance_lamps() const;
  inline void set_clearance_lamps(bool value);

  // optional bool warn_light = 15 [default = false];
  inline bool has_warn_light() const;
  inline void clear_warn_light();
  static const int kWarnLightFieldNumber = 15;
  inline bool warn_light() const;
  inline void set_warn_light(bool value);

  // optional bool parking_brake = 16 [default = false];
  inline bool has_parking_brake() const;
  inline void clear_parking_brake();
  static const int kParkingBrakeFieldNumber = 16;
  inline bool parking_brake() const;
  inline void set_parking_brake(bool value);

  // optional .chassis.LongitudeDrivingMode longitude_driving_mode = 20;
  inline bool has_longitude_driving_mode() const;
  inline void clear_longitude_driving_mode();
  static const int kLongitudeDrivingModeFieldNumber = 20;
  inline ::chassis::LongitudeDrivingMode longitude_driving_mode() const;
  inline void set_longitude_driving_mode(::chassis::LongitudeDrivingMode value);

  // optional .chassis.EPSSteeringMode eps_steering_mode = 21;
  inline bool has_eps_steering_mode() const;
  inline void clear_eps_steering_mode();
  static const int kEpsSteeringModeFieldNumber = 21;
  inline ::chassis::EPSSteeringMode eps_steering_mode() const;
  inline void set_eps_steering_mode(::chassis::EPSSteeringMode value);

  // optional uint32 steering_sign = 22;
  inline bool has_steering_sign() const;
  inline void clear_steering_sign();
  static const int kSteeringSignFieldNumber = 22;
  inline ::google::protobuf::uint32 steering_sign() const;
  inline void set_steering_sign(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chassis.VehicleState)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pilot_mode();
  inline void clear_has_pilot_mode();
  inline void set_has_steering();
  inline void clear_has_steering();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_throttle();
  inline void clear_has_throttle();
  inline void set_has_brake();
  inline void clear_has_brake();
  inline void set_has_gear();
  inline void clear_has_gear();
  inline void set_has_light();
  inline void clear_has_light();
  inline void set_has_horn();
  inline void clear_has_horn();
  inline void set_has_highbeam();
  inline void clear_has_highbeam();
  inline void set_has_lowbeam();
  inline void clear_has_lowbeam();
  inline void set_has_foglight();
  inline void clear_has_foglight();
  inline void set_has_clearance_lamps();
  inline void clear_has_clearance_lamps();
  inline void set_has_warn_light();
  inline void clear_has_warn_light();
  inline void set_has_parking_brake();
  inline void clear_has_parking_brake();
  inline void set_has_longitude_driving_mode();
  inline void clear_has_longitude_driving_mode();
  inline void set_has_eps_steering_mode();
  inline void clear_has_eps_steering_mode();
  inline void set_has_steering_sign();
  inline void clear_has_steering_sign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::Header* header_;
  int pilot_mode_;
  float steering_;
  float speed_;
  float accel_;
  float throttle_;
  float brake_;
  int gear_;
  int light_;
  bool horn_;
  bool highbeam_;
  bool lowbeam_;
  bool foglight_;
  bool clearance_lamps_;
  bool warn_light_;
  bool parking_brake_;
  int longitude_driving_mode_;
  int eps_steering_mode_;
  ::google::protobuf::uint32 steering_sign_;
  friend void  protobuf_AddDesc_vehicle_5fstate_2eproto();
  friend void protobuf_AssignDesc_vehicle_5fstate_2eproto();
  friend void protobuf_ShutdownFile_vehicle_5fstate_2eproto();

  void InitAsDefaultInstance();
  static VehicleState* default_instance_;
};
// ===================================================================


// ===================================================================

// VehicleState

// optional .common.Header header = 1;
inline bool VehicleState::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleState::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleState::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleState::clear_header() {
  if (header_ != NULL) header_->::common::Header::Clear();
  clear_has_header();
}
inline const ::common::Header& VehicleState::header() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::common::Header* VehicleState::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::common::Header;
  // @@protoc_insertion_point(field_mutable:chassis.VehicleState.header)
  return header_;
}
inline ::common::Header* VehicleState::release_header() {
  clear_has_header();
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void VehicleState::set_allocated_header(::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:chassis.VehicleState.header)
}

// optional .chassis.PilotMode pilot_mode = 2 [default = MODE_MANUAL];
inline bool VehicleState::has_pilot_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleState::set_has_pilot_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleState::clear_has_pilot_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleState::clear_pilot_mode() {
  pilot_mode_ = 0;
  clear_has_pilot_mode();
}
inline ::chassis::PilotMode VehicleState::pilot_mode() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.pilot_mode)
  return static_cast< ::chassis::PilotMode >(pilot_mode_);
}
inline void VehicleState::set_pilot_mode(::chassis::PilotMode value) {
  assert(::chassis::PilotMode_IsValid(value));
  set_has_pilot_mode();
  pilot_mode_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.pilot_mode)
}

// optional float steering = 3 [default = 0];
inline bool VehicleState::has_steering() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleState::set_has_steering() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleState::clear_has_steering() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleState::clear_steering() {
  steering_ = 0;
  clear_has_steering();
}
inline float VehicleState::steering() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.steering)
  return steering_;
}
inline void VehicleState::set_steering(float value) {
  set_has_steering();
  steering_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.steering)
}

// optional float speed = 4 [default = 0];
inline bool VehicleState::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleState::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleState::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleState::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float VehicleState::speed() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.speed)
  return speed_;
}
inline void VehicleState::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.speed)
}

// optional float accel = 5 [default = 0];
inline bool VehicleState::has_accel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleState::set_has_accel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleState::clear_has_accel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleState::clear_accel() {
  accel_ = 0;
  clear_has_accel();
}
inline float VehicleState::accel() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.accel)
  return accel_;
}
inline void VehicleState::set_accel(float value) {
  set_has_accel();
  accel_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.accel)
}

// optional float throttle = 6 [default = 0];
inline bool VehicleState::has_throttle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleState::set_has_throttle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleState::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleState::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
inline float VehicleState::throttle() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.throttle)
  return throttle_;
}
inline void VehicleState::set_throttle(float value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.throttle)
}

// optional float brake = 7 [default = 0];
inline bool VehicleState::has_brake() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleState::set_has_brake() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleState::clear_has_brake() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleState::clear_brake() {
  brake_ = 0;
  clear_has_brake();
}
inline float VehicleState::brake() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.brake)
  return brake_;
}
inline void VehicleState::set_brake(float value) {
  set_has_brake();
  brake_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.brake)
}

// optional .chassis.GearPosition gear = 8 [default = GEAR_NONE];
inline bool VehicleState::has_gear() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleState::set_has_gear() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleState::clear_has_gear() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleState::clear_gear() {
  gear_ = 0;
  clear_has_gear();
}
inline ::chassis::GearPosition VehicleState::gear() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.gear)
  return static_cast< ::chassis::GearPosition >(gear_);
}
inline void VehicleState::set_gear(::chassis::GearPosition value) {
  assert(::chassis::GearPosition_IsValid(value));
  set_has_gear();
  gear_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.gear)
}

// optional .chassis.LightSwitch light = 9 [default = LIGHT_NONE];
inline bool VehicleState::has_light() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleState::set_has_light() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleState::clear_has_light() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleState::clear_light() {
  light_ = 0;
  clear_has_light();
}
inline ::chassis::LightSwitch VehicleState::light() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.light)
  return static_cast< ::chassis::LightSwitch >(light_);
}
inline void VehicleState::set_light(::chassis::LightSwitch value) {
  assert(::chassis::LightSwitch_IsValid(value));
  set_has_light();
  light_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.light)
}

// optional bool horn = 10 [default = false];
inline bool VehicleState::has_horn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleState::set_has_horn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleState::clear_has_horn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleState::clear_horn() {
  horn_ = false;
  clear_has_horn();
}
inline bool VehicleState::horn() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.horn)
  return horn_;
}
inline void VehicleState::set_horn(bool value) {
  set_has_horn();
  horn_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.horn)
}

// optional bool highbeam = 11 [default = false];
inline bool VehicleState::has_highbeam() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleState::set_has_highbeam() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleState::clear_has_highbeam() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleState::clear_highbeam() {
  highbeam_ = false;
  clear_has_highbeam();
}
inline bool VehicleState::highbeam() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.highbeam)
  return highbeam_;
}
inline void VehicleState::set_highbeam(bool value) {
  set_has_highbeam();
  highbeam_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.highbeam)
}

// optional bool lowbeam = 12 [default = false];
inline bool VehicleState::has_lowbeam() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleState::set_has_lowbeam() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleState::clear_has_lowbeam() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleState::clear_lowbeam() {
  lowbeam_ = false;
  clear_has_lowbeam();
}
inline bool VehicleState::lowbeam() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.lowbeam)
  return lowbeam_;
}
inline void VehicleState::set_lowbeam(bool value) {
  set_has_lowbeam();
  lowbeam_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.lowbeam)
}

// optional bool foglight = 13 [default = false];
inline bool VehicleState::has_foglight() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VehicleState::set_has_foglight() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VehicleState::clear_has_foglight() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VehicleState::clear_foglight() {
  foglight_ = false;
  clear_has_foglight();
}
inline bool VehicleState::foglight() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.foglight)
  return foglight_;
}
inline void VehicleState::set_foglight(bool value) {
  set_has_foglight();
  foglight_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.foglight)
}

// optional bool clearance_lamps = 14 [default = false];
inline bool VehicleState::has_clearance_lamps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VehicleState::set_has_clearance_lamps() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VehicleState::clear_has_clearance_lamps() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VehicleState::clear_clearance_lamps() {
  clearance_lamps_ = false;
  clear_has_clearance_lamps();
}
inline bool VehicleState::clearance_lamps() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.clearance_lamps)
  return clearance_lamps_;
}
inline void VehicleState::set_clearance_lamps(bool value) {
  set_has_clearance_lamps();
  clearance_lamps_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.clearance_lamps)
}

// optional bool warn_light = 15 [default = false];
inline bool VehicleState::has_warn_light() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VehicleState::set_has_warn_light() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VehicleState::clear_has_warn_light() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VehicleState::clear_warn_light() {
  warn_light_ = false;
  clear_has_warn_light();
}
inline bool VehicleState::warn_light() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.warn_light)
  return warn_light_;
}
inline void VehicleState::set_warn_light(bool value) {
  set_has_warn_light();
  warn_light_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.warn_light)
}

// optional bool parking_brake = 16 [default = false];
inline bool VehicleState::has_parking_brake() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VehicleState::set_has_parking_brake() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VehicleState::clear_has_parking_brake() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VehicleState::clear_parking_brake() {
  parking_brake_ = false;
  clear_has_parking_brake();
}
inline bool VehicleState::parking_brake() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.parking_brake)
  return parking_brake_;
}
inline void VehicleState::set_parking_brake(bool value) {
  set_has_parking_brake();
  parking_brake_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.parking_brake)
}

// optional .chassis.LongitudeDrivingMode longitude_driving_mode = 20;
inline bool VehicleState::has_longitude_driving_mode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VehicleState::set_has_longitude_driving_mode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VehicleState::clear_has_longitude_driving_mode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VehicleState::clear_longitude_driving_mode() {
  longitude_driving_mode_ = 0;
  clear_has_longitude_driving_mode();
}
inline ::chassis::LongitudeDrivingMode VehicleState::longitude_driving_mode() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.longitude_driving_mode)
  return static_cast< ::chassis::LongitudeDrivingMode >(longitude_driving_mode_);
}
inline void VehicleState::set_longitude_driving_mode(::chassis::LongitudeDrivingMode value) {
  assert(::chassis::LongitudeDrivingMode_IsValid(value));
  set_has_longitude_driving_mode();
  longitude_driving_mode_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.longitude_driving_mode)
}

// optional .chassis.EPSSteeringMode eps_steering_mode = 21;
inline bool VehicleState::has_eps_steering_mode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VehicleState::set_has_eps_steering_mode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VehicleState::clear_has_eps_steering_mode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VehicleState::clear_eps_steering_mode() {
  eps_steering_mode_ = 0;
  clear_has_eps_steering_mode();
}
inline ::chassis::EPSSteeringMode VehicleState::eps_steering_mode() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.eps_steering_mode)
  return static_cast< ::chassis::EPSSteeringMode >(eps_steering_mode_);
}
inline void VehicleState::set_eps_steering_mode(::chassis::EPSSteeringMode value) {
  assert(::chassis::EPSSteeringMode_IsValid(value));
  set_has_eps_steering_mode();
  eps_steering_mode_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.eps_steering_mode)
}

// optional uint32 steering_sign = 22;
inline bool VehicleState::has_steering_sign() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VehicleState::set_has_steering_sign() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VehicleState::clear_has_steering_sign() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VehicleState::clear_steering_sign() {
  steering_sign_ = 0u;
  clear_has_steering_sign();
}
inline ::google::protobuf::uint32 VehicleState::steering_sign() const {
  // @@protoc_insertion_point(field_get:chassis.VehicleState.steering_sign)
  return steering_sign_;
}
inline void VehicleState::set_steering_sign(::google::protobuf::uint32 value) {
  set_has_steering_sign();
  steering_sign_ = value;
  // @@protoc_insertion_point(field_set:chassis.VehicleState.steering_sign)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace chassis

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vehicle_5fstate_2eproto__INCLUDED
