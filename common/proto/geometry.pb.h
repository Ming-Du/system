// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#ifndef PROTOBUF_geometry_2eproto__INCLUDED
#define PROTOBUF_geometry_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace geometry {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_geometry_2eproto();
void protobuf_AssignDesc_geometry_2eproto();
void protobuf_ShutdownFile_geometry_2eproto();

class Vector3;
class Point;
class Quaternion;
class Polygon;
class Transform;
class Pose;
class Accel;
class Twist;

// ===================================================================

class Vector3 : public ::google::protobuf::Message {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  Vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:geometry.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:geometry.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  Quaternion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // optional double w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline double w() const;
  inline void set_w(double value);

  // @@protoc_insertion_point(class_scope:geometry.Quaternion)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Quaternion* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .geometry.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::geometry::Point& points(int index) const;
  inline ::geometry::Point* mutable_points(int index);
  inline ::geometry::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::geometry::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::geometry::Point >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:geometry.Polygon)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::geometry::Point > points_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  void Swap(Transform* other);

  // implements Message ----------------------------------------------

  Transform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.Vector3 translation = 1;
  inline bool has_translation() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 1;
  inline const ::geometry::Vector3& translation() const;
  inline ::geometry::Vector3* mutable_translation();
  inline ::geometry::Vector3* release_translation();
  inline void set_allocated_translation(::geometry::Vector3* translation);

  // optional .geometry.Quaternion rotation = 2;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 2;
  inline const ::geometry::Quaternion& rotation() const;
  inline ::geometry::Quaternion* mutable_rotation();
  inline ::geometry::Quaternion* release_rotation();
  inline void set_allocated_rotation(::geometry::Quaternion* rotation);

  // @@protoc_insertion_point(class_scope:geometry.Transform)
 private:
  inline void set_has_translation();
  inline void clear_has_translation();
  inline void set_has_rotation();
  inline void clear_has_rotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::geometry::Vector3* translation_;
  ::geometry::Quaternion* rotation_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Transform* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  Pose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.Point position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::geometry::Point& position() const;
  inline ::geometry::Point* mutable_position();
  inline ::geometry::Point* release_position();
  inline void set_allocated_position(::geometry::Point* position);

  // optional .geometry.Quaternion orientation = 2;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  inline const ::geometry::Quaternion& orientation() const;
  inline ::geometry::Quaternion* mutable_orientation();
  inline ::geometry::Quaternion* release_orientation();
  inline void set_allocated_orientation(::geometry::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:geometry.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::geometry::Point* position_;
  ::geometry::Quaternion* orientation_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class Accel : public ::google::protobuf::Message {
 public:
  Accel();
  virtual ~Accel();

  Accel(const Accel& from);

  inline Accel& operator=(const Accel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Accel& default_instance();

  void Swap(Accel* other);

  // implements Message ----------------------------------------------

  Accel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Accel& from);
  void MergeFrom(const Accel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.Vector3 linear = 1;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 1;
  inline const ::geometry::Vector3& linear() const;
  inline ::geometry::Vector3* mutable_linear();
  inline ::geometry::Vector3* release_linear();
  inline void set_allocated_linear(::geometry::Vector3* linear);

  // optional .geometry.Vector3 angular = 2;
  inline bool has_angular() const;
  inline void clear_angular();
  static const int kAngularFieldNumber = 2;
  inline const ::geometry::Vector3& angular() const;
  inline ::geometry::Vector3* mutable_angular();
  inline ::geometry::Vector3* release_angular();
  inline void set_allocated_angular(::geometry::Vector3* angular);

  // @@protoc_insertion_point(class_scope:geometry.Accel)
 private:
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_angular();
  inline void clear_has_angular();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::geometry::Vector3* linear_;
  ::geometry::Vector3* angular_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Accel* default_instance_;
};
// -------------------------------------------------------------------

class Twist : public ::google::protobuf::Message {
 public:
  Twist();
  virtual ~Twist();

  Twist(const Twist& from);

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Twist& default_instance();

  void Swap(Twist* other);

  // implements Message ----------------------------------------------

  Twist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Twist& from);
  void MergeFrom(const Twist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.Vector3 linear = 1;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 1;
  inline const ::geometry::Vector3& linear() const;
  inline ::geometry::Vector3* mutable_linear();
  inline ::geometry::Vector3* release_linear();
  inline void set_allocated_linear(::geometry::Vector3* linear);

  // optional .geometry.Vector3 angular = 2;
  inline bool has_angular() const;
  inline void clear_angular();
  static const int kAngularFieldNumber = 2;
  inline const ::geometry::Vector3& angular() const;
  inline ::geometry::Vector3* mutable_angular();
  inline ::geometry::Vector3* release_angular();
  inline void set_allocated_angular(::geometry::Vector3* angular);

  // @@protoc_insertion_point(class_scope:geometry.Twist)
 private:
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_angular();
  inline void clear_has_angular();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::geometry::Vector3* linear_;
  ::geometry::Vector3* angular_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Twist* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector3

// optional double x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:geometry.Vector3.x)
  return x_;
}
inline void Vector3::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:geometry.Vector3.x)
}

// optional double y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:geometry.Vector3.y)
  return y_;
}
inline void Vector3::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:geometry.Vector3.y)
}

// optional double z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:geometry.Vector3.z)
  return z_;
}
inline void Vector3::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:geometry.Vector3.z)
}

// -------------------------------------------------------------------

// Point

// optional double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:geometry.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:geometry.Point.x)
}

// optional double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:geometry.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:geometry.Point.y)
}

// optional double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:geometry.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:geometry.Point.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:geometry.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:geometry.Quaternion.x)
}

// optional double y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:geometry.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:geometry.Quaternion.y)
}

// optional double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:geometry.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:geometry.Quaternion.z)
}

// optional double w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:geometry.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:geometry.Quaternion.w)
}

// -------------------------------------------------------------------

// Polygon

// repeated .geometry.Point points = 1;
inline int Polygon::points_size() const {
  return points_.size();
}
inline void Polygon::clear_points() {
  points_.Clear();
}
inline const ::geometry::Point& Polygon::points(int index) const {
  // @@protoc_insertion_point(field_get:geometry.Polygon.points)
  return points_.Get(index);
}
inline ::geometry::Point* Polygon::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:geometry.Polygon.points)
  return points_.Mutable(index);
}
inline ::geometry::Point* Polygon::add_points() {
  // @@protoc_insertion_point(field_add:geometry.Polygon.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geometry::Point >&
Polygon::points() const {
  // @@protoc_insertion_point(field_list:geometry.Polygon.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::geometry::Point >*
Polygon::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:geometry.Polygon.points)
  return &points_;
}

// -------------------------------------------------------------------

// Transform

// optional .geometry.Vector3 translation = 1;
inline bool Transform::has_translation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transform::set_has_translation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transform::clear_has_translation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transform::clear_translation() {
  if (translation_ != NULL) translation_->::geometry::Vector3::Clear();
  clear_has_translation();
}
inline const ::geometry::Vector3& Transform::translation() const {
  // @@protoc_insertion_point(field_get:geometry.Transform.translation)
  return translation_ != NULL ? *translation_ : *default_instance_->translation_;
}
inline ::geometry::Vector3* Transform::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) translation_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:geometry.Transform.translation)
  return translation_;
}
inline ::geometry::Vector3* Transform::release_translation() {
  clear_has_translation();
  ::geometry::Vector3* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Transform::set_allocated_translation(::geometry::Vector3* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Transform.translation)
}

// optional .geometry.Quaternion rotation = 2;
inline bool Transform::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transform::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transform::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transform::clear_rotation() {
  if (rotation_ != NULL) rotation_->::geometry::Quaternion::Clear();
  clear_has_rotation();
}
inline const ::geometry::Quaternion& Transform::rotation() const {
  // @@protoc_insertion_point(field_get:geometry.Transform.rotation)
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::geometry::Quaternion* Transform::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::geometry::Quaternion;
  // @@protoc_insertion_point(field_mutable:geometry.Transform.rotation)
  return rotation_;
}
inline ::geometry::Quaternion* Transform::release_rotation() {
  clear_has_rotation();
  ::geometry::Quaternion* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void Transform::set_allocated_rotation(::geometry::Quaternion* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Transform.rotation)
}

// -------------------------------------------------------------------

// Pose

// optional .geometry.Point position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::geometry::Point::Clear();
  clear_has_position();
}
inline const ::geometry::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:geometry.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::geometry::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::geometry::Point;
  // @@protoc_insertion_point(field_mutable:geometry.Pose.position)
  return position_;
}
inline ::geometry::Point* Pose::release_position() {
  clear_has_position();
  ::geometry::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::geometry::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Pose.position)
}

// optional .geometry.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::geometry::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::geometry::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:geometry.Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::geometry::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::geometry::Quaternion;
  // @@protoc_insertion_point(field_mutable:geometry.Pose.orientation)
  return orientation_;
}
inline ::geometry::Quaternion* Pose::release_orientation() {
  clear_has_orientation();
  ::geometry::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orientation(::geometry::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Pose.orientation)
}

// -------------------------------------------------------------------

// Accel

// optional .geometry.Vector3 linear = 1;
inline bool Accel::has_linear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Accel::set_has_linear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Accel::clear_has_linear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Accel::clear_linear() {
  if (linear_ != NULL) linear_->::geometry::Vector3::Clear();
  clear_has_linear();
}
inline const ::geometry::Vector3& Accel::linear() const {
  // @@protoc_insertion_point(field_get:geometry.Accel.linear)
  return linear_ != NULL ? *linear_ : *default_instance_->linear_;
}
inline ::geometry::Vector3* Accel::mutable_linear() {
  set_has_linear();
  if (linear_ == NULL) linear_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:geometry.Accel.linear)
  return linear_;
}
inline ::geometry::Vector3* Accel::release_linear() {
  clear_has_linear();
  ::geometry::Vector3* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline void Accel::set_allocated_linear(::geometry::Vector3* linear) {
  delete linear_;
  linear_ = linear;
  if (linear) {
    set_has_linear();
  } else {
    clear_has_linear();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Accel.linear)
}

// optional .geometry.Vector3 angular = 2;
inline bool Accel::has_angular() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Accel::set_has_angular() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Accel::clear_has_angular() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Accel::clear_angular() {
  if (angular_ != NULL) angular_->::geometry::Vector3::Clear();
  clear_has_angular();
}
inline const ::geometry::Vector3& Accel::angular() const {
  // @@protoc_insertion_point(field_get:geometry.Accel.angular)
  return angular_ != NULL ? *angular_ : *default_instance_->angular_;
}
inline ::geometry::Vector3* Accel::mutable_angular() {
  set_has_angular();
  if (angular_ == NULL) angular_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:geometry.Accel.angular)
  return angular_;
}
inline ::geometry::Vector3* Accel::release_angular() {
  clear_has_angular();
  ::geometry::Vector3* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline void Accel::set_allocated_angular(::geometry::Vector3* angular) {
  delete angular_;
  angular_ = angular;
  if (angular) {
    set_has_angular();
  } else {
    clear_has_angular();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Accel.angular)
}

// -------------------------------------------------------------------

// Twist

// optional .geometry.Vector3 linear = 1;
inline bool Twist::has_linear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Twist::set_has_linear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Twist::clear_has_linear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Twist::clear_linear() {
  if (linear_ != NULL) linear_->::geometry::Vector3::Clear();
  clear_has_linear();
}
inline const ::geometry::Vector3& Twist::linear() const {
  // @@protoc_insertion_point(field_get:geometry.Twist.linear)
  return linear_ != NULL ? *linear_ : *default_instance_->linear_;
}
inline ::geometry::Vector3* Twist::mutable_linear() {
  set_has_linear();
  if (linear_ == NULL) linear_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:geometry.Twist.linear)
  return linear_;
}
inline ::geometry::Vector3* Twist::release_linear() {
  clear_has_linear();
  ::geometry::Vector3* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline void Twist::set_allocated_linear(::geometry::Vector3* linear) {
  delete linear_;
  linear_ = linear;
  if (linear) {
    set_has_linear();
  } else {
    clear_has_linear();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Twist.linear)
}

// optional .geometry.Vector3 angular = 2;
inline bool Twist::has_angular() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Twist::set_has_angular() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Twist::clear_has_angular() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Twist::clear_angular() {
  if (angular_ != NULL) angular_->::geometry::Vector3::Clear();
  clear_has_angular();
}
inline const ::geometry::Vector3& Twist::angular() const {
  // @@protoc_insertion_point(field_get:geometry.Twist.angular)
  return angular_ != NULL ? *angular_ : *default_instance_->angular_;
}
inline ::geometry::Vector3* Twist::mutable_angular() {
  set_has_angular();
  if (angular_ == NULL) angular_ = new ::geometry::Vector3;
  // @@protoc_insertion_point(field_mutable:geometry.Twist.angular)
  return angular_;
}
inline ::geometry::Vector3* Twist::release_angular() {
  clear_has_angular();
  ::geometry::Vector3* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline void Twist::set_allocated_angular(::geometry::Vector3* angular) {
  delete angular_;
  angular_ = angular;
  if (angular) {
    set_has_angular();
  } else {
    clear_has_angular();
  }
  // @@protoc_insertion_point(field_set_allocated:geometry.Twist.angular)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace geometry

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_geometry_2eproto__INCLUDED
